<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法应用 | To Be Your Salt]]></title>
  <link href="http://bigbear2017.github.io/blog/categories/suan-fa-ying-yong/atom.xml" rel="self"/>
  <link href="http://bigbear2017.github.io/"/>
  <updated>2016-06-08T23:01:08+08:00</updated>
  <id>http://bigbear2017.github.io/</id>
  <author>
    <name><![CDATA[Cao Nannan]]></name>
    <email><![CDATA[sei_michael@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Calibretion算法介绍]]></title>
    <link href="http://bigbear2017.github.io/blog/2016/06/01/calibrationsuan-fa-jie-shao/"/>
    <updated>2016-06-01T23:59:03+08:00</updated>
    <id>http://bigbear2017.github.io/blog/2016/06/01/calibrationsuan-fa-jie-shao</id>
    <content type="html"><![CDATA[<h5>版权声明：本文所有内容都是原创，如有转载请注明出处，谢谢。</h5>

<h3>什么是Calibretion?</h3>

<p>在进行点击率预估的过程中，我们发现这样一个现象。把所有点击率按照从小到大排序，然后每n个点击，计算copc（clicks over predicted clicks ），得到分段copc。如下图：
<img src="http://7xv0xu.com1.z0.glb.clouddn.com/copc-1.png" alt="copc1" />
从上面的图，我们可以看到这样一个情况，在整条的曲线上，我们都会看到有时高估，有时低估。尤其在曲线的尾部，高估的严重，我们预估有10个点击，估计也就有3个点击左右。所以，我们需要进行矫正，让整条曲线都在1附近。</p>

<h3>如何矫正</h3>

<p>在进行矫正的时候，我们需要满足这样的条件:</p>

<ol>
<li>不可以改变目前预估的排序，因为如果改变了预估的排序，那么整个曲线的auc就会发生变化。</li>
<li>保证矫正以后的copc在1附近。这样我们矫正才有意义。</li>
</ol>


<p>解决的方式是我们使用Isotonic Regression 进行矫正。保序回归，刚刚好满足上面的要求。</p>

<h3>什么是保序回归</h3>

<p>简单地来说，保序回归的意思是这样，对于任意$n$个点$(a_1, a_2, &hellip;, a_n)$, 找到n个点$(x_1, x_2, &hellip; , x_n)$，使得$\sum_{i=1}^n (x_i - a_i)^2$最小，并且对于任意的$i > j$，我们有$x_i \ge x_j$。比如下图中有100个点，从1到100个红色的点，蓝色是用linear regression解出来的线，绿色是保序回归解出来的线。
<img src="http://7xv0xu.com1.z0.glb.clouddn.com/plot_isotonic_regression_1.png" alt="isotonic-regression" /></p>

<h3>PAVA (Pool Adjacent Violation Algorithm)算法</h3>

<p>为了解决上面的问题，有人提出了PAVA算法。简单地来说，检查相邻两个block，还不能达到单调递增的状态，那么就将这两个block放在一起，合并成一个大的block。再对这个block，进行求解，之后递归上面的操作。
<code>
merge all values into blocks
solve each block,
if the condition is not satisfied, repeat step 1
</code>
用伪代码翻译下，可以得到下面这样的结果</p>

<pre><code>输入: $ {(x_i, y_i)} $， 其中$x_i$为index，$y_i$为value
sort( {x_i, y_i} ) according to $x_i$
for each record (x_i, x_i, y_i) R
  merge Record R into RecordList L

def  mergeList( record R, recordList L ) :
    if L is empty:
      insert R to L and return
    get last record LR
    if LR.value &lt; R.value:
      return 
    else:
       remove LR from L
       merge LR and  R to Rnew
       mergeList( Rnew, L )
</code></pre>

<p>PAVA 算法非常快，只需要O(n)的时间就好了，也非常有效。</p>

<h4>算法演示:</h4>

<p><img src="http://7xv0xu.com1.z0.glb.clouddn.com/isotonic.gif" alt="pava-gif" /></p>

<h3>纠正后的效果</h3>

<p>如下图:
<img src="http://7xv0xu.com1.z0.glb.clouddn.com/copc-2.png" alt="copc2" />
从上图，我们可以看到，整个曲线都在1附近。</p>
]]></content>
  </entry>
  
</feed>
